# Stock Returns Based On PE Ratios

```elixir
Mix.install(
  [
    {:nx, "~> 0.5.3"},
    {:explorer, "~> 0.6.1"},
    {:kino, "~> 0.10.0"},
    {:kino_vega_lite, "~> 0.1.9"},
    {:kino_explorer, "~> 0.1.8"},
    {:exla, "~> 0.5.3"},
    {:axon, "~> 0.5.1"}
  ],
  config: [nx: [default_backend: EXLA.Backend]]
)
```

## Read In The CSVs

```elixir
require Explorer.DataFrame, as: DF

paths =
  "~/Dropbox/stocks/*.csv"
  |> Path.expand()
  |> Path.wildcard()

dates =
  Enum.map(paths, fn path ->
    Code.eval_quoted(
      quote do
        Date.new(
          unquote_splicing(
            Enum.map(String.split(Path.basename(path, ".csv"), "-"), &String.to_integer/1)
          )
        )
      end
    )
  end)

dates = Enum.map(dates, fn date -> elem(elem(date, 0), 1) end)
dataframes = Enum.map(paths, fn path -> Explorer.DataFrame.from_csv!(path, header: false) end)

dataframes =
  Enum.map(dataframes, fn df -> Explorer.DataFrame.rename(df, ["ticker", "price", "pe_ratio"]) end)

date_lists =
  Enum.with_index(dataframes, fn df, i ->
    fn -> Enum.at(dates, i) end
    |> Stream.repeatedly()
    |> Enum.take(Explorer.Series.count(df["ticker"]))
  end)

date_series = Enum.map(date_lists, fn date_list -> Explorer.DataFrame.new(date: date_list) end)

dataframes =
  Enum.with_index(dataframes, fn df, i -> DF.concat_columns(df, Enum.at(date_series, i)) end)

dataframes =
  Enum.map(dataframes, fn df ->
    DF.mutate(df, %{date: cast(date, :date)})
  end)
```

## Concat The Rows

```elixir
require Explorer.DataFrame, as: DF

total_df = DF.concat_rows(dataframes)
total_df = DF.mutate(total_df, %{ticker: cast(ticker, :category)})
```

## Sort By Ticker

```elixir
require Explorer.DataFrame, as: DF

tickers = Explorer.Series.categories(total_df["ticker"])
total_df = DF.mutate(total_df, %{ticker: cast(ticker, :string)})

ticker_dfs =
  Enum.map(Explorer.Series.to_list(tickers), fn ticker ->
    DF.filter(total_df, ticker == ^ticker)
  end)

length(ticker_dfs)
```

## Shift By 1 And Take Percent Change

```elixir
require Explorer.DataFrame, as: DF

shifted_ticker_dfs =
  Enum.map(ticker_dfs, fn df ->
    DF.mutate(df, %{price_shifted: Explorer.Series.shift(price, 1)})
  end)

ticker_dfs_with_percentages =
  Enum.map(shifted_ticker_dfs, fn df ->
    DF.mutate(df, %{percent_change: (price - price_shifted) / price_shifted})
  end)

# drop the first row
ticker_dfs_with_percentages = Enum.map(ticker_dfs_with_percentages, fn df -> DF.drop_nil(df) end)
```

## Shape The Data

```elixir
prediction_days_text = Kino.Input.text("Num Prediction Days")
```

```elixir
prediction_days = String.to_integer(Kino.Input.read(prediction_days_text))

slice_fun = fn df ->
  x =
    for i <- prediction_days..(elem(DF.shape(df), 0) - 1) do
      df
      |> DF.select(["price", "pe_ratio", "percent_change"])
      |> DF.slice((i - prediction_days)..(i - 1))
    end

  y =
    for i <- prediction_days..(elem(DF.shape(df), 0) - 1) do
      Explorer.Series.to_tensor(DF.slice(df, [i])["percent_change"])[0]
    end

  [x, y]
end

sliced_frames = Enum.map(ticker_dfs_with_percentages, fn df -> slice_fun.(df) end)
```

## Train/Test Split

```elixir
test_num_text = Kino.Input.text("Number of Test Cases")
```

```elixir
require Explorer.DataFrame, as: DF

test_num = String.to_integer(Kino.Input.read(test_num_text))

train_test_split_fun = fn x_tensors, y_tensors ->
  [x_train, x_test] = [
    Enum.slice(x_tensors, 0..-test_num//1),
    Enum.slice(x_tensors, -test_num..-1)
  ]

  [y_train, y_test] = [
    Enum.slice(y_tensors, 0..-test_num//1),
    Enum.slice(y_tensors, -test_num..-1)
  ]

  [[x_train, y_train], [x_test, y_test]]
end

train_test_split = Enum.map(sliced_frames, fn [x, y] -> train_test_split_fun.(x, y) end)
```
